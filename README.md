# cp-dsa-practice
A structured Competitive Programming and Data Structures &amp; Algorithms practice repository containing daily problem solving, optimized approaches, and pattern-based learning across platforms like LeetCode, GFG, and Codeforces.

Competitive Programming & DSA Practice
This repository contains my daily practice of Data Structures and Algorithms.
The goal is to build:
Strong problem-solving skills
Pattern recognition ability
Interview-ready thinking
Optimized coding habits

Problems are solved consistently and organized topic-wise for easy revision.
Each file contains:
Problem Link
Approach
Code
Optimized Method (if applicable)

Platforms Covered
LeetCode
GeeksforGeeks
Codeforces

Goals

Maintain daily consistency
Improve logical thinking
Strengthen core DSA concepts
Prepare for technical interview


| S.No | Category       | Name                       | Description                                                                                   |
| ---- | -------------- | -------------------------- | --------------------------------------------------------------------------------------------- |
| 1    | Data Structure | Array                      | A collection of elements identified by index; fixed size and continuous memory allocation.    |
| 2    | Data Structure | Linked List                | A sequence of nodes where each node points to the next; supports dynamic memory allocation.   |
| 3    | Data Structure | Stack                      | LIFO (Last-In-First-Out) data structure; supports push and pop operations.                    |
| 4    | Data Structure | Queue                      | FIFO (First-In-First-Out) data structure; supports enqueue and dequeue operations.            |
| 5    | Data Structure | Deque                      | Double-ended queue supporting insertion and deletion at both ends.                            |
| 6    | Data Structure | Hash Table / Hash Map      | Key-value pair mapping allowing O(1) average lookup, insert, and delete operations.           |
| 7    | Data Structure | Binary Tree                | Hierarchical structure where each node has at most two children.                              |
| 8    | Data Structure | Binary Search Tree (BST)   | Binary tree with left child < node and right child > node; supports efficient searching.      |
| 9    | Data Structure | Heap                       | Complete binary tree used for implementing priority queues; max-heap or min-heap.             |
| 10   | Data Structure | Graph                      | Nodes connected by edges; can be directed/undirected, weighted/unweighted.                    |
| 11   | Algorithm      | Linear Search              | Sequentially checks each element until the target is found; O(n) time complexity.             |
| 12   | Algorithm      | Binary Search              | Searches a sorted array by repeatedly dividing the search interval in half; O(log n).         |
| 13   | Algorithm      | Bubble Sort                | Simple sorting algorithm; repeatedly swaps adjacent elements if they are in wrong order.      |
| 14   | Algorithm      | Insertion Sort             | Builds the sorted array one element at a time; inserts each element at the correct position.  |
| 15   | Algorithm      | Merge Sort                 | Divide and conquer sorting algorithm; divides the array and merges sorted halves; O(n log n). |
| 16   | Algorithm      | Quick Sort                 | Divide and conquer algorithm; selects a pivot and partitions array; average O(n log n).       |
| 17   | Algorithm      | Dijkstra's Algorithm       | Finds shortest paths from a source node to all other nodes in a weighted graph.               |
| 18   | Algorithm      | Depth-First Search (DFS)   | Graph traversal algorithm exploring as far as possible along each branch before backtracking. |
| 19   | Algorithm      | Breadth-First Search (BFS) | Graph traversal algorithm exploring neighbors before moving to the next level.                |
| 20   | Algorithm      | Dynamic Programming        | Optimizes problems by storing results of overlapping subproblems to avoid recomputation.      |

Time complexity:

<img width="1258" height="862" alt="time_complexity" src="https://github.com/user-attachments/assets/fd832811-d843-4779-8956-fd0b30a95d0e" />

Sorting algorithm:

<img width="755" height="483" alt="sorting" src="https://github.com/user-attachments/assets/2c719706-fe50-4e2a-8867-9bc12b6195ec" />

